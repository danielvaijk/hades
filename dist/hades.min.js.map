{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/objects/Mutation.js","webpack:///./src/objects/EnumEntry.js","webpack:///./src/objects/enums/MutationTypeEnum.js","webpack:///./src/objects/errors/HadesValidationError.js","webpack:///./src/model/Model.js","webpack:///./src/objects/enums/FieldTypeEnum.js","webpack:///./src/model/Schema.js","webpack:///./src/database/Table.js","webpack:///./src/objects/errors/HadesUnexpectedValueError.js","webpack:///./src/database/Session.js","webpack:///./src/database/Database.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Mutation","options","this","_type","type","_ModelClass","ModelClass","_fieldsOrNull","fields","_modelIdOrNull","modelId","_willApplyToEntireTable","willApplyToEntireTable","EnumEntry","_key","_value","entry","getKey","MutationTypeEnum","HadesValidationError","Error","Model","session","tableKey","identifierKey","modelSchemaDefinition","fieldValuesOrNull","_getInstanceRowFromStateOrNull","castValuesAgainstDefinition","applyMutation","INSERT","UPSERT","DELETE","UPDATE","state","rows","FieldTypeEnum","FieldClass","Schema","schemaDefinition","IDENTIFIER","fieldValues","definedIdentifierFieldNameOrNull","getDefinedIdentifierFieldNameOrNull","fieldNameIdentifier","GLOBAL_DEFAULT_KEY_NAME_ID","entries","reduce","fieldInstances","fieldName","fieldValue","getValue","Number","fieldWhitelist","isFieldSuperfluous","includes","keys","forEach","toString","join","fieldDefinitions","fieldIdentifierIndex","findIndex","equals","GLOBAL_INDEX_INVALID","Table","_createStorageForRows","_meta","_createStorageForMeta","_keyTable","_getModelTableName","_keyIdentifier","_getModelIdentifierFieldName","JSON","parse","stringify","columns","_getNextId","idBlacklist","push","sort","a","b","lastIdIncremental","rowId","assign","updateRow","insertRow","rowIdBlacklistIndex","indexOf","splice","findNextNonBlacklistedId","id","idBlacklistIndex","length","toLowerCase","HadesUnexpectedValueError","Session","models","mutation","getType","getModelClass","pointerModelTableOrNull","_getPointerForModelTableOrNull","modelIdOrNull","getModelIdOrNull","fieldsOrNull","getFieldsOrNull","getWillApplyToEntireTable","assertSchemaAllowsFieldsForMutation","_applyInsertMutation","_applyUpsertMutation","_applyDeleteMutation","_applyUpdateMutation","tableKeyOrNull","getTableKeyOrNull","pointerTable","truncate","deleteRow","upsertRow","Database","_registerModels","action","_createSession","_forModelsInSessionCreateTablesIfNeeded","_forModelsInSessionApplyReducers","registeredModels","uniqueModels","_createWarningDuplicateModel","addModels","addSession","table","addTableKey","addIdentifierKey","getIdentifierKey","mergeIntoState","reducer","modelName","console","warn"],"mappings":"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","file":"hades.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// @flow strict\nimport type { Model } from \"../model/Model\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\n\ntype MutationOptionsType = {|\n    type: EnumEntry,\n    modelId?: number,\n    fields?: TableRowType,\n    ModelClass: Class<Model>,\n    willApplyToEntireTable?: boolean,\n|};\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200919 Initial creation.\n */\nclass Mutation {\n    _type: EnumEntry;\n    _ModelClass: Class<Model>;\n    _modelIdOrNull: number | null;\n    _willApplyToEntireTable: boolean;\n    _fieldsOrNull: TableRowType | null;\n\n    /**\n     * @param {MutationOptionsType} options\n     */\n    constructor(options: MutationOptionsType): void {\n        this._type = options.type;\n        this._ModelClass = options.ModelClass;\n        this._fieldsOrNull = options.fields || null;\n        this._modelIdOrNull = options.modelId || null;\n        this._willApplyToEntireTable = options.willApplyToEntireTable || false;\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    getType(): EnumEntry {\n        return this._type;\n    }\n\n    /**\n     * @returns {Class<Model>}\n     */\n    getModelClass(): Class<Model> {\n        return this._ModelClass;\n    }\n\n    /**\n     * @returns {number|null}\n     */\n    getModelIdOrNull(): number | null {\n        return this._modelIdOrNull;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    getWillApplyToEntireTable(): boolean {\n        return this._willApplyToEntireTable;\n    }\n\n    /**\n     * @returns {FieldsForMutation|null}\n     */\n    getFieldsOrNull(): TableRowType | null {\n        return this._fieldsOrNull;\n    }\n}\n\nexport { Mutation };\n","// @flow strict\n/* eslint-disable flowtype/no-weak-types */\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass EnumEntry {\n    _key: string;\n    _value: any;\n\n    /**\n     * @param {string} key\n     * @param {any} value\n     */\n    constructor(key: string, value: any): void {\n        this._key = key;\n        this._value = value;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._key;\n    }\n\n    /**\n     * @returns {any}\n     */\n    getValue(): any {\n        return this._value;\n    }\n\n    /**\n     * @param {EnumEntry} entry\n     *\n     * @returns {boolean}\n     */\n    equals(entry: EnumEntry): boolean {\n        return entry.getKey() === this._key;\n    }\n}\n\nexport { EnumEntry };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst MUTATION_TYPE_INSERT: string = \"INSERT\";\nconst MUTATION_TYPE_UPDATE: string = \"UPDATE\";\nconst MUTATION_TYPE_UPSERT: string = \"UPSERT\";\nconst MUTATION_TYPE_DELETE: string = \"DELETE\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass MutationTypeEnum {\n    /**\n     * @returns {EnumEntry}\n     */\n    static INSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_INSERT, MUTATION_TYPE_INSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPDATE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPDATE, MUTATION_TYPE_UPDATE);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPSERT, MUTATION_TYPE_UPSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static DELETE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_DELETE, MUTATION_TYPE_DELETE);\n    }\n}\n\nexport { MutationTypeEnum };\n","// @flow strict\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesValidationError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return \"HadesValidationError\";\n    }\n\n    /**\n     * @param {string} value\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesValidationError };\n","// @flow strict\nimport type { Schema } from \"./Schema\";\nimport { Mutation } from \"../objects/Mutation\";\nimport type { Session } from \"../database/Session\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Model {\n    modelId: number;\n    session: Session;\n    tableKey: string;\n    identifierKey: string;\n    fields: ModelFieldsType;\n    ModelClass: Class<Model>;\n\n    static session: Session;\n    static tableKey: string;\n    static identifierKey: string;\n\n    static fields: () => Schema;\n    static toString: () => string;\n    static reducer: (action: ActionType) => void;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {number} modelId\n     */\n    constructor(ModelClass: Class<Model>, modelId: number): void {\n        this.modelId = modelId;\n        this.ModelClass = ModelClass;\n        this.session = this.ModelClass.session;\n        this.tableKey = this.ModelClass.tableKey;\n        this.identifierKey = this.ModelClass.identifierKey;\n\n        const modelSchemaDefinition: Schema = this.ModelClass.fields();\n        const fieldValuesOrNull: Model | null = this._getInstanceRowFromStateOrNull();\n\n        if (fieldValuesOrNull) {\n            this.fields = modelSchemaDefinition.castValuesAgainstDefinition(\n                fieldValuesOrNull\n            );\n        } else {\n            throw new HadesValidationError(\n                \"No data exists for this Model instance.\"\n            );\n        }\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    update(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this.ModelClass,\n                type: MutationTypeEnum.UPDATE(),\n                modelId: this.fields[this.identifierKey],\n            })\n        );\n    }\n\n    /**\n     */\n    delete(): void {\n        this.session.applyMutation(\n            new Mutation({\n                ModelClass: this.ModelClass,\n                type: MutationTypeEnum.DELETE(),\n                modelId: this.fields[this.identifierKey],\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    static create(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.INSERT(),\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    static upsert(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.UPSERT(),\n            })\n        );\n    }\n\n    /**\n     */\n    static deleteAll(): void {\n        this.session.applyMutation(\n            new Mutation({\n                ModelClass: this,\n                willApplyToEntireTable: true,\n                type: MutationTypeEnum.DELETE(),\n            })\n        );\n    }\n\n    /**\n     * @param {string} modelId\n     *\n     * @returns {Model}\n     */\n    static withId(modelId: number): Model {\n        return new Model(this, modelId);\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    static getTableKeyOrNull(): string | null {\n        return this.tableKey || null;\n    }\n\n    /**\n     * @param {string} tableKey\n     */\n    static addTableKey(tableKey: string): void {\n        this.tableKey = tableKey;\n    }\n\n    /**\n     * @param {string} identifierKey\n     */\n    static addIdentifierKey(identifierKey: string): void {\n        this.identifierKey = identifierKey;\n    }\n\n    /**\n     * @param {Session} session\n     */\n    static addSession(session: Session): void {\n        this.session = session;\n    }\n\n    /**\n     * @returns {Model|null}\n     */\n    _getInstanceRowFromStateOrNull(): Model | null {\n        return this.session.state[this.tableKey].rows[this.modelId] || null;\n    }\n}\n\nexport { Model };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst FIELD_TYPE_IDENTIFIER: string = \"IDENTIFIER\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201010 Initial creation.\n */\nclass FieldTypeEnum {\n    /**\n     * @param {FieldClassType} [FieldClass]\n     *\n     * @returns {EnumEntry}\n     */\n    static IDENTIFIER(FieldClass: ?FieldClassType): EnumEntry {\n        return new EnumEntry(FIELD_TYPE_IDENTIFIER, FieldClass);\n    }\n}\n\nexport { FieldTypeEnum };\n","// @flow strict\n/* global GLOBAL_INDEX_INVALID */\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"./Model\";\nimport { EnumEntry } from \"../objects/EnumEntry\";\nimport { FieldTypeEnum } from \"../objects/enums/FieldTypeEnum\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\nopaque type FieldDefinitionType = FieldClassType | EnumEntry;\nopaque type FieldInstancesType = [string, FieldDefinitionType];\n\nopaque type SchemaDefinitionType = {|\n    [fieldName: string]: FieldDefinitionType,\n|};\n\n/**\n * Type constants.\n */\nconst TYPE_UNDEFINED: string = \"undefined\";\n\n/**\n * Separator constants.\n */\nconst SEPARATOR_SPACE: string = \" \";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200722 Initial creation.\n */\nclass Schema {\n    schemaDefinition: SchemaDefinitionType;\n\n    /**\n     * @param {SchemaDefinitionType} schemaDefinition\n     */\n    constructor(schemaDefinition: SchemaDefinitionType): void {\n        this.schemaDefinition = schemaDefinition;\n    }\n\n    /**\n     * @param {FieldClassType} FieldClass\n     *\n     * @returns {EnumEntry}\n     */\n    static defineIdentifierField(FieldClass: FieldClassType): EnumEntry {\n        return FieldTypeEnum.IDENTIFIER(FieldClass);\n    }\n\n    /**\n     * @param {TableRowType} fieldValues\n     *\n     * @returns {ModelFieldsType}\n     * @throws {HadesValidationError}\n     */\n    castValuesAgainstDefinition(fieldValues: TableRowType): ModelFieldsType {\n        const definedIdentifierFieldNameOrNull:\n            | string\n            | null = this.getDefinedIdentifierFieldNameOrNull();\n        const fieldNameIdentifier: string =\n            definedIdentifierFieldNameOrNull || GLOBAL_DEFAULT_KEY_NAME_ID;\n\n        if (fieldValues[fieldNameIdentifier]) {\n            // Value for identifier field was provided.\n        } else {\n            throw new HadesValidationError(\n                `Value is required for identifier field '${fieldNameIdentifier}'.`\n            );\n        }\n\n        /**\n         * @param {SchemaDefinitionType} fieldInstances\n         * @param {FieldInstancesType} currentField\n         *\n         * @returns {SchemaDefinitionType}\n         */\n        function reduceSchemaDefinition(\n            fieldInstances: SchemaDefinitionType,\n            [fieldName, fieldValue]: FieldInstancesType\n        ): SchemaDefinitionType {\n            const FieldClass: FieldClassType =\n                fieldValue instanceof EnumEntry\n                    ? fieldValue.getValue()\n                    : fieldValue;\n\n            return {\n                ...fieldInstances,\n                [fieldName]: new FieldClass(fieldValues[fieldName]),\n            };\n        }\n\n        /**\n         * @returns {SchemaDefinitionType}\n         *\n         * @this Schema\n         */\n        function determineSchemaDefinitionBase(): SchemaDefinitionType {\n            if (definedIdentifierFieldNameOrNull) {\n                return {};\n            } else {\n                return {\n                    [GLOBAL_DEFAULT_KEY_NAME_ID]: Number(\n                        fieldValues[GLOBAL_DEFAULT_KEY_NAME_ID]\n                    ),\n                };\n            }\n        }\n\n        // $FlowIssue\n        return Object.entries(this.schemaDefinition).reduce(\n            reduceSchemaDefinition,\n            determineSchemaDefinitionBase.call(this)\n        );\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {TableRowType} fields\n     *\n     * @throws {HadesValidationError}\n     */\n    assertSchemaAllowsFieldsForMutation(\n        ModelClass: Class<Model>,\n        fields: TableRowType\n    ): void {\n        const fieldWhitelist: Array<string> = [GLOBAL_DEFAULT_KEY_NAME_ID];\n\n        /**\n         * @param {string} key\n         *\n         * @returns {boolean}\n         *\n         * @this Schema\n         */\n        function isFieldSuperfluous(key: string): boolean {\n            return (\n                fieldWhitelist.includes(key) === false &&\n                typeof this.schemaDefinition[key] === TYPE_UNDEFINED\n            );\n        }\n\n        Object.keys(fields).forEach((key: string): void => {\n            if (isFieldSuperfluous.call(this, key)) {\n                throw new HadesValidationError(\n                    [\n                        `Cannot apply mutation to ${ModelClass.toString()} model,`,\n                        `found superfluous property '${key}'.`,\n                    ].join(SEPARATOR_SPACE)\n                );\n            } else {\n                // Field is allowed.\n            }\n        });\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    getDefinedIdentifierFieldNameOrNull(): string | null {\n        // $FlowIssue\n        const fieldDefinitions: Array<FieldInstancesType> = Object.entries(\n            this.schemaDefinition\n        );\n        const fieldIdentifierIndex: number = fieldDefinitions.findIndex(\n            // $FlowIssue\n            // eslint-disable-next-line no-unused-vars\n            ([fieldName, fieldValue]: FieldInstancesType): boolean => {\n                return (\n                    fieldValue instanceof EnumEntry &&\n                    fieldValue.equals(FieldTypeEnum.IDENTIFIER())\n                );\n            }\n        );\n\n        if (fieldIdentifierIndex === GLOBAL_INDEX_INVALID) {\n            return null;\n        } else {\n            return fieldDefinitions[fieldIdentifierIndex][0];\n        }\n    }\n}\n\nexport { Schema };\n","// @flow strict\n/* global GLOBAL_INDEX_INVALID */\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"../model/Model\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\nopaque type RowStorageType = { ... };\n\nopaque type MetaStorageType = {|\n    lastIdIncremental: number,\n    idBlacklist: Array<number>,\n|};\n\n/**\n * Table constants.\n */\nconst TABLE_NAME_PREFIX: string = \"table_\";\n\n/**\n * Counter constants.\n */\nconst INCREMENT_STEP: number = 1;\nconst INCREMENT_START: number = 0;\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Table {\n    rows: RowStorageType;\n\n    _keyTable: string;\n    _keyIdentifier: string;\n    _meta: MetaStorageType;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     */\n    constructor(ModelClass: Class<Model>): void {\n        this.rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n        this._keyTable = this._getModelTableName(ModelClass);\n        this._keyIdentifier = this._getModelIdentifierFieldName(ModelClass);\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._keyTable;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getIdentifierKey(): string {\n        return this._keyIdentifier;\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    getRows(): RowStorageType {\n        return JSON.parse(JSON.stringify(this.rows));\n    }\n\n    /**\n     * @param {TableRowType} columns\n     */\n    insertRow(columns: TableRowType): void {\n        /**\n         * @returns {number}\n         *\n         * @this Table\n         */\n        function determineModelId(): number {\n            if (columns[this._keyIdentifier]) {\n                return columns[this._keyIdentifier];\n            } else {\n                return this._getNextId();\n            }\n        }\n\n        const modelId: number = determineModelId.call(this);\n\n        if (this.rows[modelId]) {\n            throw new HadesValidationError(\n                `Cannot insert new row since given ID '${modelId}' is not unique.`\n            );\n        } else {\n            this.rows[modelId] = {\n                ...columns,\n                [this._keyIdentifier]: modelId,\n            };\n\n            if (columns[this._keyIdentifier]) {\n                this._meta.idBlacklist.push(modelId);\n                this._meta.idBlacklist.sort(\n                    (a: number, b: number): number => a - b\n                );\n            } else {\n                this._meta.lastIdIncremental = modelId;\n            }\n        }\n    }\n\n    /**\n     * @param {number} rowId\n     * @param {TableRowType} columns\n     */\n    updateRow(rowId: number, columns: TableRowType): void {\n        Object.assign(this.rows[rowId], columns);\n    }\n\n    /**\n     * @param {TableRowType} columns\n     */\n    upsertRow(columns: TableRowType): void {\n        if (\n            columns[this._keyIdentifier] &&\n            this.rows[columns[this._keyIdentifier]]\n        ) {\n            this.updateRow(columns[this._keyIdentifier], columns);\n        } else {\n            this.insertRow(columns);\n        }\n    }\n\n    /**\n     * @param {number} rowId\n     */\n    deleteRow(rowId: number): void {\n        const { idBlacklist }: MetaStorageType = this._meta;\n        const rowIdBlacklistIndex: number = idBlacklist.indexOf(rowId);\n\n        if (rowIdBlacklistIndex === GLOBAL_INDEX_INVALID) {\n            // No need to clear this ID from the blacklist.\n        } else {\n            idBlacklist.splice(rowIdBlacklistIndex, 1);\n        }\n\n        delete this.rows[rowId.toString()];\n    }\n\n    /**\n     */\n    truncate(): void {\n        this.rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    _createStorageForRows(): RowStorageType {\n        return {};\n    }\n\n    /**\n     * @returns {MetaStorageType}\n     */\n    _createStorageForMeta(): MetaStorageType {\n        return {\n            idBlacklist: [],\n            lastIdIncremental: INCREMENT_START,\n        };\n    }\n\n    /**\n     * @returns {number}\n     */\n    _getNextId(): number {\n        const { idBlacklist, lastIdIncremental }: MetaStorageType = this._meta;\n        const nextIdIncremental: number = lastIdIncremental + INCREMENT_STEP;\n\n        /**\n         * @param {number} id\n         *\n         * @returns {number}\n         */\n        function findNextNonBlacklistedId(id: number): number {\n            const idBlacklistIndex: number = idBlacklist.indexOf(id);\n\n            if (idBlacklistIndex === GLOBAL_INDEX_INVALID) {\n                return id;\n            } else if (idBlacklistIndex === idBlacklist.length - 1) {\n                return id + INCREMENT_STEP;\n            } else {\n                return findNextNonBlacklistedId(id + INCREMENT_STEP);\n            }\n        }\n\n        return findNextNonBlacklistedId(nextIdIncremental);\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {string}\n     */\n    _getModelTableName(ModelClass: Class<Model>): string {\n        return `${TABLE_NAME_PREFIX}${ModelClass.toString().toLowerCase()}`;\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {string}\n     */\n    _getModelIdentifierFieldName(ModelClass: Class<Model>): string {\n        const fieldIdentifierNameOrNull:\n            | string\n            | null = ModelClass.fields().getDefinedIdentifierFieldNameOrNull();\n\n        return fieldIdentifierNameOrNull || GLOBAL_DEFAULT_KEY_NAME_ID;\n    }\n}\n\nexport { Table };\n","// @flow strict\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesUnexpectedValueError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return \"HadesUnexpectedValueError\";\n    }\n\n    /**\n     * @param {string} value\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesUnexpectedValueError };\n","// @flow strict\nimport type { Table } from \"./Table\";\nimport type { Model } from \"../model/Model\";\nimport type { Mutation } from \"../objects/Mutation\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesUnexpectedValueError } from \"../objects/errors/HadesUnexpectedValueError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Session {\n    state: StateType;\n    models: Array<Class<Model>>;\n\n    /**\n     * @param {StateType} state\n     */\n    constructor(state: StateType): void {\n        this.state = state;\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    addModels(models: Array<Class<Model>>): void {\n        this.models = models;\n    }\n\n    /**\n     * @param {StateType} object\n     */\n    mergeIntoState(object: StateType): void {\n        Object.assign(this.state, object);\n    }\n\n    /**\n     * @param {Mutation} mutation\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    applyMutation(mutation: Mutation): void {\n        const type: EnumEntry = mutation.getType();\n        const ModelClass: Class<Model> = mutation.getModelClass();\n        const pointerModelTableOrNull: Table | null = this._getPointerForModelTableOrNull(\n            ModelClass\n        );\n\n        if (pointerModelTableOrNull) {\n            // Found pointer to model's table.\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Cannot apply mutation to Model without table pointer.\"\n            );\n        }\n\n        const modelIdOrNull: number | null = mutation.getModelIdOrNull();\n        const fieldsOrNull: TableRowType | null = mutation.getFieldsOrNull();\n        const willApplyToEntireTable: boolean = mutation.getWillApplyToEntireTable();\n\n        if (fieldsOrNull) {\n            ModelClass.fields().assertSchemaAllowsFieldsForMutation(\n                ModelClass,\n                fieldsOrNull\n            );\n        } else {\n            // No fields for this mutation type.\n        }\n\n        if (type.equals(MutationTypeEnum.INSERT())) {\n            this._applyInsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.UPSERT())) {\n            this._applyUpsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.DELETE())) {\n            this._applyDeleteMutation(\n                pointerModelTableOrNull,\n                modelIdOrNull,\n                willApplyToEntireTable\n            );\n        } else if (type.equals(MutationTypeEnum.UPDATE())) {\n            this._applyUpdateMutation(\n                pointerModelTableOrNull,\n                fieldsOrNull,\n                modelIdOrNull\n            );\n        } else {\n            throw new HadesUnexpectedValueError(\n                `Unexpected mutation type '${type.getValue()}'.`\n            );\n        }\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {Table|null}\n     */\n    _getPointerForModelTableOrNull(ModelClass: Class<Model>): Table | null {\n        const tableKeyOrNull: string | null = ModelClass.getTableKeyOrNull();\n\n        if (tableKeyOrNull) {\n            return this.state[tableKeyOrNull];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {number|null} modelIdOrNull\n     * @param {boolean} willApplyToEntireTable\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyDeleteMutation(\n        pointerTable: Table,\n        modelIdOrNull: number | null,\n        willApplyToEntireTable: boolean\n    ): void {\n        if (willApplyToEntireTable) {\n            pointerTable.truncate();\n        } else if (modelIdOrNull) {\n            pointerTable.deleteRow(modelIdOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for DELETE MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyInsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.insertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for INSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.upsertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     * @param {number|null} modelIdOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpdateMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null,\n        modelIdOrNull: number | null\n    ): void {\n        if (fieldsOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPDATE MutationType.\"\n            );\n        } else if (modelIdOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for UPDATE MutationType.\"\n            );\n        } else {\n            pointerTable.updateRow(modelIdOrNull, fieldsOrNull);\n        }\n    }\n}\n\nexport { Session };\n","// @flow strict\nimport { Table } from \"./Table\";\nimport { Session } from \"./Session\";\nimport type { Model } from \"../model/Model\";\n\n/**\n * Type constants.\n */\nconst TYPE_FUNCTION: string = \"function\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Database {\n    registeredModels: Array<Class<Model>>;\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    constructor(...models: Array<Class<Model>>): void {\n        this._registerModels(models);\n    }\n\n    /**\n     * @returns {Function}\n     */\n    reducer(): (state: StateType, action: ActionType) => StateType {\n        /**\n         * @param {StateType} [state]\n         * @param {ActionType} action\n         *\n         * @returns {StateType}\n         */\n        return (state: StateType = {}, action: ActionType): StateType => {\n            const session: Session = this._createSession(state);\n\n            this._forModelsInSessionCreateTablesIfNeeded(session);\n            this._forModelsInSessionApplyReducers(session, action);\n\n            return session.state;\n        };\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    _registerModels(models: Array<Class<Model>>): void {\n        /**\n         * @param {Array<Class<Model>>} uniqueModels\n         * @param {Class<Model>} ModelClass\n         *\n         * @this Database\n         *\n         * @returns {Array<Class<Model>>}\n         */\n        function uniqueModelReducer(\n            uniqueModels: Array<Class<Model>>,\n            ModelClass: Class<Model>\n        ): Array<Class<Model>> {\n            if (uniqueModels.includes(ModelClass)) {\n                this._createWarningDuplicateModel(ModelClass.toString());\n            } else {\n                uniqueModels.push(ModelClass);\n            }\n\n            return uniqueModels;\n        }\n\n        this.registeredModels = models.reduce(\n            uniqueModelReducer.bind(this),\n            []\n        );\n    }\n\n    /**\n     * @param {StateType} state\n     *\n     * @returns {Session}\n     */\n    _createSession(state: StateType): Session {\n        const session: Session = new Session(state);\n\n        session.addModels(this.registeredModels);\n        this.registeredModels.forEach((ModelClass: Class<Model>): void => {\n            ModelClass.addSession(session);\n        });\n\n        return session;\n    }\n\n    /**\n     * @param {Session} session\n     */\n    _forModelsInSessionCreateTablesIfNeeded(session: Session): void {\n        session.models.forEach((ModelClass: Class<Model>): void => {\n            const tableKeyOrNull:\n                | string\n                | null = ModelClass.getTableKeyOrNull();\n\n            if (tableKeyOrNull && session.state[tableKeyOrNull]) {\n                // Table already exists.\n            } else {\n                const table: Table = new Table(ModelClass);\n                const tableKey: string = table.getKey();\n\n                ModelClass.addTableKey(tableKey);\n                ModelClass.addIdentifierKey(table.getIdentifierKey());\n\n                session.mergeIntoState({ [tableKey]: table });\n            }\n        });\n    }\n\n    /**\n     * @param {Session} session\n     * @param {ActionType} action\n     */\n    _forModelsInSessionApplyReducers(\n        session: Session,\n        action: ActionType\n    ): void {\n        session.models.forEach((ModelClass: Class<Model>): void => {\n            if (typeof ModelClass.reducer === TYPE_FUNCTION) {\n                ModelClass.reducer(action);\n            } else {\n                // No reducer defined for this model.\n            }\n        });\n    }\n\n    /**\n     * @param {string} modelName\n     */\n    _createWarningDuplicateModel(modelName: string): void {\n        console.warn(`Tried to register duplicate Model: '${modelName}'.`);\n    }\n}\n\nexport { Database };\n"],"sourceRoot":""}