{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/objects/Mutation.js","webpack:///./src/objects/EnumEntry.js","webpack:///./src/objects/enums/MutationTypeEnum.js","webpack:///./src/objects/errors/HadesValidationError.js","webpack:///./src/model/Model.js","webpack:///./src/objects/enums/FieldTypeEnum.js","webpack:///./src/model/Schema.js","webpack:///./src/database/Table.js","webpack:///./src/objects/errors/HadesUnexpectedValueError.js","webpack:///./src/database/Session.js","webpack:///./src/database/Database.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Mutation","options","this","_type","type","_ModelClass","ModelClass","_fieldsOrNull","fields","_modelIdOrNull","modelId","_willApplyToEntireTable","willApplyToEntireTable","EnumEntry","_key","_value","entry","getKey","MutationTypeEnum","HadesValidationError","Error","Model","_modelId","_session","session","_tableKey","tableKey","_identifierKey","identifierKey","modelSchemaDefinition","fieldValuesOrNull","_getFieldValuesFromTableOrNull","_fields","castValuesAgainstDefinition","applyMutation","INSERT","UPSERT","DELETE","UPDATE","getState","tableOrNull","_getTableInstanceOrNull","getRows","FieldTypeEnum","FieldClass","Schema","schemaDefinition","_schemaDefinition","IDENTIFIER","fieldValues","definedIdentifierFieldNameOrNull","getDefinedIdentifierFieldNameOrNull","fieldNameIdentifier","GLOBAL_DEFAULT_KEY_NAME_ID","entries","reduce","fieldInstances","fieldName","fieldValue","getValue","Number","fieldWhitelist","isFieldSuperfluous","includes","GLOBAL_TYPE_UNDEFINED","keys","forEach","toString","join","GLOBAL_SEPARATOR_SPACE","fieldDefinitions","fieldIdentifierIndex","findIndex","equals","GLOBAL_INDEX_INVALID","Table","_rows","_createStorageForRows","_meta","_createStorageForMeta","_keyTable","_getModelTableName","_keyIdentifierOrNull","_getModelIdentifierFieldNameOrNull","JSON","parse","stringify","columns","getIdentifierKey","_getNextId","idBlacklist","push","sort","a","b","lastIdIncremental","rowId","assign","updateRow","insertRow","rowIdBlacklistIndex","indexOf","splice","findNextNonBlacklistedId","id","idBlacklistIndex","length","toLowerCase","HadesUnexpectedValueError","Session","state","_state","_models","models","mutation","getType","getModelClass","pointerModelTableOrNull","_getPointerForModelTableOrNull","modelIdOrNull","getModelIdOrNull","fieldsOrNull","getFieldsOrNull","getWillApplyToEntireTable","assertSchemaAllowsFieldsForMutation","_applyInsertMutation","_applyUpsertMutation","_applyDeleteMutation","_applyUpdateMutation","tableKeyOrNull","getTableKeyOrNull","pointerTable","truncate","deleteRow","upsertRow","Database","_registerModels","action","_createSession","_forModelsInSessionCreateTablesIfNeeded","_forModelsInSessionApplyReducers","_registeredModels","uniqueModels","_createWarningDuplicateModel","addModels","addSession","getModels","table","addTableKey","addIdentifierKey","mergeIntoState","reducer","modelName","console","warn"],"mappings":"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","file":"hades.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// @flow strict\nimport type { Model } from \"../model/Model\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\n\ntype MutationOptionsType = {|\n    type: EnumEntry,\n    modelId?: number,\n    fields?: TableRowType,\n    ModelClass: Class<Model>,\n    willApplyToEntireTable?: boolean,\n|};\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200919 Initial creation.\n */\nclass Mutation {\n    _type: EnumEntry;\n    _ModelClass: Class<Model>;\n    _modelIdOrNull: number | null;\n    _willApplyToEntireTable: boolean;\n    _fieldsOrNull: TableRowType | null;\n\n    /**\n     * @param {MutationOptionsType} options\n     */\n    constructor(options: MutationOptionsType): void {\n        this._type = options.type;\n        this._ModelClass = options.ModelClass;\n        this._fieldsOrNull = options.fields || null;\n        this._modelIdOrNull = options.modelId || null;\n        this._willApplyToEntireTable = options.willApplyToEntireTable || false;\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    getType(): EnumEntry {\n        return this._type;\n    }\n\n    /**\n     * @returns {Class<Model>}\n     */\n    getModelClass(): Class<Model> {\n        return this._ModelClass;\n    }\n\n    /**\n     * @returns {number|null}\n     */\n    getModelIdOrNull(): number | null {\n        return this._modelIdOrNull;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    getWillApplyToEntireTable(): boolean {\n        return this._willApplyToEntireTable;\n    }\n\n    /**\n     * @returns {FieldsForMutation|null}\n     */\n    getFieldsOrNull(): TableRowType | null {\n        return this._fieldsOrNull;\n    }\n}\n\nexport { Mutation };\n","// @flow strict\n/* eslint-disable flowtype/no-weak-types */\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass EnumEntry {\n    _key: string;\n    _value: any;\n\n    /**\n     * @param {string} key\n     * @param {any} value\n     */\n    constructor(key: string, value: any): void {\n        this._key = key;\n        this._value = value;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._key;\n    }\n\n    /**\n     * @returns {any}\n     */\n    getValue(): any {\n        return this._value;\n    }\n\n    /**\n     * @param {EnumEntry} entry\n     *\n     * @returns {boolean}\n     */\n    equals(entry: EnumEntry): boolean {\n        return entry.getKey() === this._key;\n    }\n}\n\nexport { EnumEntry };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst MUTATION_TYPE_INSERT: string = \"INSERT\";\nconst MUTATION_TYPE_UPDATE: string = \"UPDATE\";\nconst MUTATION_TYPE_UPSERT: string = \"UPSERT\";\nconst MUTATION_TYPE_DELETE: string = \"DELETE\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass MutationTypeEnum {\n    /**\n     * @returns {EnumEntry}\n     */\n    static INSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_INSERT, MUTATION_TYPE_INSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPDATE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPDATE, MUTATION_TYPE_UPDATE);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPSERT, MUTATION_TYPE_UPSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static DELETE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_DELETE, MUTATION_TYPE_DELETE);\n    }\n}\n\nexport { MutationTypeEnum };\n","// @flow strict\n/**\n * Error constants.\n */\nconst ERROR_NAME: string = \"HadesValidationError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesValidationError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return ERROR_NAME;\n    }\n\n    /**\n     * @param {string} value\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesValidationError };\n","// @flow strict\nimport type { Schema } from \"./Schema\";\nimport { Mutation } from \"../objects/Mutation\";\nimport type { Table } from \"../database/Table\";\nimport type { Session } from \"../database/Session\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Model {\n    _modelId: number;\n    _session: Session;\n    _tableKey: string;\n    _identifierKey: string;\n    _fields: ModelFieldsType;\n    _ModelClass: Class<Model>;\n\n    static session: Session;\n    static tableKey: string;\n    static identifierKey: string;\n\n    static fields: () => Schema;\n    static toString: () => string;\n    static reducer: (action: ActionType) => void;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {number} modelId\n     */\n    constructor(ModelClass: Class<Model>, modelId: number): void {\n        this._modelId = modelId;\n        this._ModelClass = ModelClass;\n        this._session = this._ModelClass.session;\n        this._tableKey = this._ModelClass.tableKey;\n        this._identifierKey = this._ModelClass.identifierKey;\n\n        const modelSchemaDefinition: Schema = this._ModelClass.fields();\n        const fieldValuesOrNull: Model | null = this._getFieldValuesFromTableOrNull();\n\n        if (fieldValuesOrNull) {\n            this._fields = modelSchemaDefinition.castValuesAgainstDefinition(\n                fieldValuesOrNull\n            );\n        } else {\n            throw new HadesValidationError(\n                `No data exists for Model instance with ID '${modelId}'.`\n            );\n        }\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    update(fields: TableRowType): void {\n        this._session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this._ModelClass,\n                type: MutationTypeEnum.UPDATE(),\n                modelId: this._fields[this._identifierKey],\n            })\n        );\n    }\n\n    /**\n     */\n    delete(): void {\n        this._session.applyMutation(\n            new Mutation({\n                ModelClass: this._ModelClass,\n                type: MutationTypeEnum.DELETE(),\n                modelId: this._fields[this._identifierKey],\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    static create(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.INSERT(),\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    static upsert(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.UPSERT(),\n            })\n        );\n    }\n\n    /**\n     */\n    static deleteAll(): void {\n        this.session.applyMutation(\n            new Mutation({\n                ModelClass: this,\n                willApplyToEntireTable: true,\n                type: MutationTypeEnum.DELETE(),\n            })\n        );\n    }\n\n    /**\n     * @param {string} modelId\n     *\n     * @returns {Model}\n     */\n    static withId(modelId: number): Model {\n        return new Model(this, modelId);\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    static getTableKeyOrNull(): string | null {\n        return this.tableKey || null;\n    }\n\n    /**\n     * @param {string} tableKey\n     */\n    static addTableKey(tableKey: string): void {\n        this.tableKey = tableKey;\n    }\n\n    /**\n     * @param {string} identifierKey\n     */\n    static addIdentifierKey(identifierKey: string): void {\n        this.identifierKey = identifierKey;\n    }\n\n    /**\n     * @param {Session} session\n     */\n    static addSession(session: Session): void {\n        this.session = session;\n    }\n\n    /**\n     * @returns {Table|null}\n     */\n    _getTableInstanceOrNull(): Table | null {\n        return this?._session.getState()[this._tableKey ?? \"\"] || null;\n    }\n\n    /**\n     * @returns {Model|null}\n     * @throws {HadesValidationError}\n     */\n    _getFieldValuesFromTableOrNull(): Model | null {\n        const tableOrNull: Table | null = this._getTableInstanceOrNull();\n\n        if (tableOrNull) {\n            return tableOrNull.getRows()[this._modelId] || null;\n        } else {\n            throw new HadesValidationError(\n                \"Cannot get Model instance with missing Table.\"\n            );\n        }\n    }\n}\n\nexport { Model };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst FIELD_TYPE_IDENTIFIER: string = \"IDENTIFIER\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201010 Initial creation.\n */\nclass FieldTypeEnum {\n    /**\n     * @param {FieldClassType} [FieldClass]\n     *\n     * @returns {EnumEntry}\n     */\n    static IDENTIFIER(FieldClass: ?FieldClassType): EnumEntry {\n        return new EnumEntry(FIELD_TYPE_IDENTIFIER, FieldClass);\n    }\n}\n\nexport { FieldTypeEnum };\n","// @flow strict\n/* global GLOBAL_INDEX_INVALID */\n/* global GLOBAL_TYPE_UNDEFINED */\n/* global GLOBAL_SEPARATOR_SPACE */\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"./Model\";\nimport { EnumEntry } from \"../objects/EnumEntry\";\nimport { FieldTypeEnum } from \"../objects/enums/FieldTypeEnum\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\nopaque type FieldDefinitionType = FieldClassType | EnumEntry;\nopaque type FieldInstancesType = [string, FieldDefinitionType];\nopaque type SchemaDefinitionType = {|\n    [fieldName: string]: FieldDefinitionType,\n|};\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200722 Initial creation.\n */\nclass Schema {\n    _schemaDefinition: SchemaDefinitionType;\n\n    /**\n     * @param {SchemaDefinitionType} schemaDefinition\n     */\n    constructor(schemaDefinition: SchemaDefinitionType): void {\n        this._schemaDefinition = schemaDefinition;\n    }\n\n    /**\n     * @param {FieldClassType} FieldClass\n     *\n     * @returns {EnumEntry}\n     */\n    static defineIdentifierField(FieldClass: FieldClassType): EnumEntry {\n        return FieldTypeEnum.IDENTIFIER(FieldClass);\n    }\n\n    /**\n     * @param {TableRowType} fieldValues\n     *\n     * @returns {ModelFieldsType}\n     * @throws {HadesValidationError}\n     */\n    castValuesAgainstDefinition(fieldValues: TableRowType): ModelFieldsType {\n        const definedIdentifierFieldNameOrNull:\n            | string\n            | null = this.getDefinedIdentifierFieldNameOrNull();\n        const fieldNameIdentifier: string =\n            definedIdentifierFieldNameOrNull || GLOBAL_DEFAULT_KEY_NAME_ID;\n\n        if (fieldValues[fieldNameIdentifier]) {\n            // Value for identifier field was provided.\n        } else {\n            throw new HadesValidationError(\n                `Value is required for identifier field '${fieldNameIdentifier}'.`\n            );\n        }\n\n        /**\n         * @param {SchemaDefinitionType} fieldInstances\n         * @param {FieldInstancesType} currentField\n         *\n         * @returns {SchemaDefinitionType}\n         */\n        function reduceSchemaDefinition(\n            fieldInstances: SchemaDefinitionType,\n            [fieldName, fieldValue]: FieldInstancesType\n        ): SchemaDefinitionType {\n            const FieldClass: FieldClassType =\n                fieldValue instanceof EnumEntry\n                    ? fieldValue.getValue()\n                    : fieldValue;\n\n            return {\n                ...fieldInstances,\n                [fieldName]: new FieldClass(fieldValues[fieldName]),\n            };\n        }\n\n        /**\n         * @returns {SchemaDefinitionType}\n         *\n         * @this Schema\n         */\n        function determineSchemaDefinitionBase(): SchemaDefinitionType {\n            if (definedIdentifierFieldNameOrNull) {\n                return {};\n            } else {\n                return {\n                    [GLOBAL_DEFAULT_KEY_NAME_ID]: Number(\n                        fieldValues[GLOBAL_DEFAULT_KEY_NAME_ID]\n                    ),\n                };\n            }\n        }\n\n        // $FlowIssue\n        return Object.entries(this.schemaDefinition).reduce(\n            reduceSchemaDefinition,\n            determineSchemaDefinitionBase.call(this)\n        );\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {TableRowType} fields\n     *\n     * @throws {HadesValidationError}\n     */\n    assertSchemaAllowsFieldsForMutation(\n        ModelClass: Class<Model>,\n        fields: TableRowType\n    ): void {\n        const fieldWhitelist: Array<string> = [GLOBAL_DEFAULT_KEY_NAME_ID];\n\n        /**\n         * @param {string} key\n         *\n         * @returns {boolean}\n         *\n         * @this Schema\n         */\n        function isFieldSuperfluous(key: string): boolean {\n            return (\n                fieldWhitelist.includes(key) === false &&\n                typeof this._schemaDefinition[key] === GLOBAL_TYPE_UNDEFINED\n            );\n        }\n\n        Object.keys(fields).forEach((key: string): void => {\n            if (isFieldSuperfluous.call(this, key)) {\n                throw new HadesValidationError(\n                    [\n                        `Cannot apply mutation to ${ModelClass.toString()} model,`,\n                        `found superfluous property '${key}'.`,\n                    ].join(GLOBAL_SEPARATOR_SPACE)\n                );\n            } else {\n                // Field is allowed.\n            }\n        });\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    getDefinedIdentifierFieldNameOrNull(): string | null {\n        // $FlowIssue\n        const fieldDefinitions: Array<FieldInstancesType> = Object.entries(\n            this._schemaDefinition\n        );\n        const fieldIdentifierIndex: number = fieldDefinitions.findIndex(\n            // $FlowIssue\n            // eslint-disable-next-line no-unused-vars\n            ([fieldName, fieldValue]: FieldInstancesType): boolean => {\n                return (\n                    fieldValue instanceof EnumEntry &&\n                    fieldValue.equals(FieldTypeEnum.IDENTIFIER())\n                );\n            }\n        );\n\n        if (fieldIdentifierIndex === GLOBAL_INDEX_INVALID) {\n            return null;\n        } else {\n            return fieldDefinitions[fieldIdentifierIndex][0];\n        }\n    }\n}\n\nexport { Schema };\n","// @flow strict\n/* global GLOBAL_INDEX_INVALID */\n/* global GLOBAL_TYPE_UNDEFINED */\n/* global GLOBAL_SEPARATOR_SPACE */\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"../model/Model\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\ntype RowStorageType = {|\n    // eslint-disable-next-line flowtype/no-weak-types\n    [key: string | number]: any,\n|};\n\nopaque type MetaStorageType = {|\n    lastIdIncremental: number,\n    idBlacklist: Array<number>,\n|};\n\n/**\n * Table constants.\n */\nconst TABLE_NAME_PREFIX: string = \"table_\";\n\n/**\n * Counter constants.\n */\nconst INCREMENT_STEP: number = 1;\nconst INCREMENT_START: number = 0;\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Table {\n    _keyTable: string;\n    _rows: RowStorageType;\n    _meta: MetaStorageType;\n    _keyIdentifierOrNull: string | null;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     */\n    constructor(ModelClass: Class<Model>): void {\n        this._rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n        this._keyTable = this._getModelTableName(ModelClass);\n        this._keyIdentifierOrNull = this._getModelIdentifierFieldNameOrNull(\n            ModelClass\n        );\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._keyTable;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getIdentifierKey(): string {\n        return this._keyIdentifierOrNull || GLOBAL_DEFAULT_KEY_NAME_ID;\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    getRows(): RowStorageType {\n        return JSON.parse(JSON.stringify(this._rows));\n    }\n\n    /**\n     * @param {TableRowType} columns\n     */\n    insertRow(columns: TableRowType): void {\n        const identifierKey: string = this.getIdentifierKey();\n\n        if (\n            this._keyIdentifierOrNull &&\n            typeof columns[this._keyIdentifierOrNull] === GLOBAL_TYPE_UNDEFINED\n        ) {\n            throw new HadesValidationError(\n                [\n                    \"Cannot insert Table row with missing value for\",\n                    `defined identifier '${this._keyIdentifierOrNull}'.`,\n                ].join(GLOBAL_SEPARATOR_SPACE)\n            );\n        } else {\n            // We're using the default identifier. So, move on.\n        }\n\n        /**\n         * @returns {number}\n         *\n         * @this Table\n         */\n        function determineModelId(): number {\n            if (columns[identifierKey]) {\n                return columns[identifierKey];\n            } else {\n                return this._getNextId();\n            }\n        }\n\n        const modelId: number = determineModelId.call(this);\n\n        if (this._rows[modelId]) {\n            throw new HadesValidationError(\n                `Cannot insert new Table row since given ID '${modelId}' is not unique.`\n            );\n        } else {\n            this._rows[modelId] = {\n                ...columns,\n                [identifierKey]: modelId,\n            };\n\n            if (columns[identifierKey]) {\n                this._meta.idBlacklist.push(modelId);\n                this._meta.idBlacklist.sort(\n                    (a: number, b: number): number => a - b\n                );\n            } else {\n                this._meta.lastIdIncremental = modelId;\n            }\n        }\n    }\n\n    /**\n     * @param {number} rowId\n     * @param {TableRowType} columns\n     */\n    updateRow(rowId: number, columns: TableRowType): void {\n        Object.assign(this._rows[rowId], columns);\n    }\n\n    /**\n     * @param {TableRowType} columns\n     */\n    upsertRow(columns: TableRowType): void {\n        const identifierKey: string = this.getIdentifierKey();\n\n        if (columns[identifierKey] && this._rows[columns[identifierKey]]) {\n            this.updateRow(columns[identifierKey], columns);\n        } else {\n            this.insertRow(columns);\n        }\n    }\n\n    /**\n     * @param {number} rowId\n     */\n    deleteRow(rowId: number): void {\n        const { idBlacklist }: MetaStorageType = this._meta;\n        const rowIdBlacklistIndex: number = idBlacklist.indexOf(rowId);\n\n        if (rowIdBlacklistIndex === GLOBAL_INDEX_INVALID) {\n            // No need to clear this ID from the blacklist.\n        } else {\n            idBlacklist.splice(rowIdBlacklistIndex, 1);\n        }\n\n        delete this._rows[rowId.toString()];\n    }\n\n    /**\n     */\n    truncate(): void {\n        this._rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    _createStorageForRows(): RowStorageType {\n        return {};\n    }\n\n    /**\n     * @returns {MetaStorageType}\n     */\n    _createStorageForMeta(): MetaStorageType {\n        return {\n            idBlacklist: [],\n            lastIdIncremental: INCREMENT_START,\n        };\n    }\n\n    /**\n     * @returns {number}\n     */\n    _getNextId(): number {\n        const { idBlacklist, lastIdIncremental }: MetaStorageType = this._meta;\n        const nextIdIncremental: number = lastIdIncremental + INCREMENT_STEP;\n\n        /**\n         * @param {number} id\n         *\n         * @returns {number}\n         */\n        function findNextNonBlacklistedId(id: number): number {\n            const idBlacklistIndex: number = idBlacklist.indexOf(id);\n\n            if (idBlacklistIndex === GLOBAL_INDEX_INVALID) {\n                return id;\n            } else if (idBlacklistIndex === idBlacklist.length - 1) {\n                return id + INCREMENT_STEP;\n            } else {\n                return findNextNonBlacklistedId(id + INCREMENT_STEP);\n            }\n        }\n\n        return findNextNonBlacklistedId(nextIdIncremental);\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {string}\n     */\n    _getModelTableName(ModelClass: Class<Model>): string {\n        return `${TABLE_NAME_PREFIX}${ModelClass.toString().toLowerCase()}`;\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {string|null}\n     */\n    _getModelIdentifierFieldNameOrNull(\n        ModelClass: Class<Model>\n    ): string | null {\n        const fieldIdentifierNameOrNull:\n            | string\n            | null = ModelClass.fields().getDefinedIdentifierFieldNameOrNull();\n\n        return fieldIdentifierNameOrNull;\n    }\n}\n\nexport { Table };\n","// @flow strict\n/**\n * Error constants.\n */\nconst ERROR_NAME: string = \"HadesUnexpectedValueError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesUnexpectedValueError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return ERROR_NAME;\n    }\n\n    /**\n     * @param {string} value\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesUnexpectedValueError };\n","// @flow strict\nimport type { Table } from \"./Table\";\nimport type { Model } from \"../model/Model\";\nimport type { Mutation } from \"../objects/Mutation\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesUnexpectedValueError } from \"../objects/errors/HadesUnexpectedValueError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Session {\n    _state: StateType;\n    _models: Array<Class<Model>>;\n\n    /**\n     * @param {StateType} state\n     */\n    constructor(state: StateType): void {\n        this._state = state;\n    }\n\n    /**\n     * @returns {StateType}\n     */\n    getState(): StateType {\n        return this._state;\n    }\n\n    /**\n     * @returns {Array<Class<Model>>}\n     */\n    getModels(): Array<Class<Model>> {\n        return this._models;\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    addModels(models: Array<Class<Model>>): void {\n        this._models = models;\n    }\n\n    /**\n     * @param {StateType} object\n     */\n    mergeIntoState(object: StateType): void {\n        Object.assign(this._state, object);\n    }\n\n    /**\n     * @param {Mutation} mutation\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    applyMutation(mutation: Mutation): void {\n        const type: EnumEntry = mutation.getType();\n        const ModelClass: Class<Model> = mutation.getModelClass();\n        const pointerModelTableOrNull: Table | null = this._getPointerForModelTableOrNull(\n            ModelClass\n        );\n\n        if (pointerModelTableOrNull) {\n            // Found pointer to model's table.\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Cannot apply mutation to Model without table pointer.\"\n            );\n        }\n\n        const modelIdOrNull: number | null = mutation.getModelIdOrNull();\n        const fieldsOrNull: TableRowType | null = mutation.getFieldsOrNull();\n        const willApplyToEntireTable: boolean = mutation.getWillApplyToEntireTable();\n\n        if (fieldsOrNull) {\n            ModelClass.fields().assertSchemaAllowsFieldsForMutation(\n                ModelClass,\n                fieldsOrNull\n            );\n        } else {\n            // No fields for this mutation type.\n        }\n\n        if (type.equals(MutationTypeEnum.INSERT())) {\n            this._applyInsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.UPSERT())) {\n            this._applyUpsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.DELETE())) {\n            this._applyDeleteMutation(\n                pointerModelTableOrNull,\n                modelIdOrNull,\n                willApplyToEntireTable\n            );\n        } else if (type.equals(MutationTypeEnum.UPDATE())) {\n            this._applyUpdateMutation(\n                pointerModelTableOrNull,\n                fieldsOrNull,\n                modelIdOrNull\n            );\n        } else {\n            throw new HadesUnexpectedValueError(\n                `Unexpected mutation type '${type.getValue()}'.`\n            );\n        }\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {Table|null}\n     */\n    _getPointerForModelTableOrNull(ModelClass: Class<Model>): Table | null {\n        const tableKeyOrNull: string | null = ModelClass.getTableKeyOrNull();\n\n        if (tableKeyOrNull) {\n            return this._state[tableKeyOrNull];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {number|null} modelIdOrNull\n     * @param {boolean} willApplyToEntireTable\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyDeleteMutation(\n        pointerTable: Table,\n        modelIdOrNull: number | null,\n        willApplyToEntireTable: boolean\n    ): void {\n        if (willApplyToEntireTable) {\n            pointerTable.truncate();\n        } else if (modelIdOrNull) {\n            pointerTable.deleteRow(modelIdOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for DELETE MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyInsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.insertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for INSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.upsertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     * @param {number|null} modelIdOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpdateMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null,\n        modelIdOrNull: number | null\n    ): void {\n        if (fieldsOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPDATE MutationType.\"\n            );\n        } else if (modelIdOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for UPDATE MutationType.\"\n            );\n        } else {\n            pointerTable.updateRow(modelIdOrNull, fieldsOrNull);\n        }\n    }\n}\n\nexport { Session };\n","// @flow strict\nimport { Table } from \"./Table\";\nimport { Session } from \"./Session\";\nimport type { Model } from \"../model/Model\";\n\n/**\n * Type constants.\n */\nconst TYPE_FUNCTION: string = \"function\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Database {\n    _registeredModels: Array<Class<Model>>;\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    constructor(...models: Array<Class<Model>>): void {\n        this._registerModels(models);\n    }\n\n    /**\n     * @returns {Function}\n     */\n    reducer(): (state: StateType, action: ActionType) => StateType {\n        /**\n         * @param {StateType} [state]\n         * @param {ActionType} action\n         *\n         * @returns {StateType}\n         */\n        return (state: StateType = {}, action: ActionType): StateType => {\n            const session: Session = this._createSession(state);\n\n            this._forModelsInSessionCreateTablesIfNeeded(session);\n            this._forModelsInSessionApplyReducers(session, action);\n\n            return session.getState();\n        };\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    _registerModels(models: Array<Class<Model>>): void {\n        /**\n         * @param {Array<Class<Model>>} uniqueModels\n         * @param {Class<Model>} ModelClass\n         *\n         * @this Database\n         *\n         * @returns {Array<Class<Model>>}\n         */\n        function uniqueModelReducer(\n            uniqueModels: Array<Class<Model>>,\n            ModelClass: Class<Model>\n        ): Array<Class<Model>> {\n            if (uniqueModels.includes(ModelClass)) {\n                this._createWarningDuplicateModel(ModelClass.toString());\n            } else {\n                uniqueModels.push(ModelClass);\n            }\n\n            return uniqueModels;\n        }\n\n        this._registeredModels = models.reduce(\n            uniqueModelReducer.bind(this),\n            []\n        );\n    }\n\n    /**\n     * @param {StateType} state\n     *\n     * @returns {Session}\n     */\n    _createSession(state: StateType): Session {\n        const session: Session = new Session(state);\n\n        session.addModels(this._registeredModels);\n        this._registeredModels.forEach((ModelClass: Class<Model>): void => {\n            ModelClass.addSession(session);\n        });\n\n        return session;\n    }\n\n    /**\n     * @param {Session} session\n     */\n    _forModelsInSessionCreateTablesIfNeeded(session: Session): void {\n        session.getModels().forEach((ModelClass: Class<Model>): void => {\n            const tableKeyOrNull:\n                | string\n                | null = ModelClass.getTableKeyOrNull();\n\n            if (tableKeyOrNull && session.getState()[tableKeyOrNull]) {\n                // Table already exists.\n            } else {\n                const table: Table = new Table(ModelClass);\n                const tableKey: string = table.getKey();\n\n                ModelClass.addTableKey(tableKey);\n                ModelClass.addIdentifierKey(table.getIdentifierKey());\n\n                session.mergeIntoState({ [tableKey]: table });\n            }\n        });\n    }\n\n    /**\n     * @param {Session} session\n     * @param {ActionType} action\n     */\n    _forModelsInSessionApplyReducers(\n        session: Session,\n        action: ActionType\n    ): void {\n        session.getModels().forEach((ModelClass: Class<Model>): void => {\n            if (typeof ModelClass.reducer === TYPE_FUNCTION) {\n                ModelClass.reducer(action);\n            } else {\n                // No reducer defined for this model.\n            }\n        });\n    }\n\n    /**\n     * @param {string} modelName\n     */\n    _createWarningDuplicateModel(modelName: string): void {\n        console.warn(`Tried to register duplicate Model: '${modelName}'.`);\n    }\n}\n\nexport { Database };\n"],"sourceRoot":""}