{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/objects/Mutation.js","webpack:///./src/objects/EnumEntry.js","webpack:///./src/objects/enums/MutationTypeEnum.js","webpack:///./src/objects/errors/HadesValidationError.js","webpack:///./src/model/Model.js","webpack:///./src/objects/enums/FieldTypeEnum.js","webpack:///./src/model/Schema.js","webpack:///./src/database/Table.js","webpack:///./src/objects/errors/HadesUnexpectedValueError.js","webpack:///./src/database/Session.js","webpack:///./src/database/Database.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Mutation","options","this","_type","type","_ModelClass","ModelClass","_fieldsOrNull","fields","_modelIdOrNull","modelId","_willApplyToEntireTable","willApplyToEntireTable","EnumEntry","_key","_value","entry","getKey","MutationTypeEnum","HadesValidationError","Error","Model","_modelId","_session","session","_tableKey","tableKey","_identifierKey","identifierKey","tableOrNull","_getTableInstanceOrNull","tableRowsOrNull","_rows","_fields","applyMutation","INSERT","UPSERT","DELETE","UPDATE","getState","FieldTypeEnum","FieldClass","Schema","schemaDefinition","_schemaDefinition","IDENTIFIER","fieldValues","isIdentifierRequired","definedIdentifierFieldNameOrNull","getDefinedIdentifierFieldNameOrNull","fieldNameIdentifier","GLOBAL_DEFAULT_KEY_NAME_ID","entries","reduce","fieldInstances","fieldName","fieldValue","getValue","Number","fieldWhitelist","isFieldSuperfluous","includes","GLOBAL_TYPE_UNDEFINED","keys","forEach","toString","join","GLOBAL_SEPARATOR_SPACE","fieldDefinitions","fieldIdentifierIndex","findIndex","equals","GLOBAL_INDEX_INVALID","Table","_createStorageForRows","_meta","_createStorageForMeta","_keyTable","_getModelTableName","_keyIdentifierOrNull","_getModelIdentifierFieldNameOrNull","JSON","parse","stringify","columns","getIdentifierKey","_getNextId","modelIdDecimal","parseInt","idBlacklist","push","sort","a","b","lastIdIncremental","rowId","assign","updateRow","insertRow","rowIdBlacklistIndex","indexOf","splice","findNextNonBlacklistedId","id","idBlacklistIndex","length","toLowerCase","HadesUnexpectedValueError","Session","state","_state","_models","models","mutation","getType","getModelClass","pointerModelTableOrNull","_getPointerForModelTableOrNull","modelIdOrNull","getModelIdOrNull","getWillApplyToEntireTable","fieldsOrNull","_getModelFieldsConvertedForMutationOrNull","getFieldsOrNull","_applyInsertMutation","_applyUpsertMutation","_applyDeleteMutation","_applyUpdateMutation","isIdentifierFieldRequired","modelSchema","assertSchemaAllowsFieldsForMutation","castValuesAgainstDefinition","tableKeyOrNull","getTableKeyOrNull","pointerTable","truncate","deleteRow","upsertRow","Database","_registerModels","action","_createSession","_forModelsInSessionCreateTablesIfNeeded","_forModelsInSessionApplyReducers","_registeredModels","uniqueModels","_createWarningDuplicateModel","addModels","addSession","getModels","table","addTableKey","addIdentifierKey","mergeIntoState","reducer","modelName","console","warn"],"mappings":"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","file":"hades.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// @flow strict\nimport type { Model } from \"../model/Model\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\n\ntype MutationOptionsType = {|\n    type: EnumEntry,\n    modelId?: number,\n    fields?: TableRowType,\n    ModelClass: Class<Model>,\n    willApplyToEntireTable?: boolean,\n|};\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200919 Initial creation.\n */\nclass Mutation {\n    _type: EnumEntry;\n    _ModelClass: Class<Model>;\n    _modelIdOrNull: number | null;\n    _willApplyToEntireTable: boolean;\n    _fieldsOrNull: TableRowType | null;\n\n    /**\n     * @param {MutationOptionsType} options\n     *\n     * @returns {void}\n     */\n    constructor(options: MutationOptionsType): void {\n        this._type = options.type;\n        this._ModelClass = options.ModelClass;\n        this._fieldsOrNull = options.fields || null;\n        this._modelIdOrNull = options.modelId || null;\n        this._willApplyToEntireTable = options.willApplyToEntireTable || false;\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    getType(): EnumEntry {\n        return this._type;\n    }\n\n    /**\n     * @returns {Class<Model>}\n     */\n    getModelClass(): Class<Model> {\n        return this._ModelClass;\n    }\n\n    /**\n     * @returns {number|null}\n     */\n    getModelIdOrNull(): number | null {\n        return this._modelIdOrNull;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    getWillApplyToEntireTable(): boolean {\n        return this._willApplyToEntireTable;\n    }\n\n    /**\n     * @returns {TableRowType|null}\n     */\n    getFieldsOrNull(): TableRowType | null {\n        return this._fieldsOrNull;\n    }\n}\n\nexport { Mutation };\n","// @flow strict\n/* eslint-disable flowtype/no-weak-types */\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass EnumEntry {\n    _key: string;\n    _value: any;\n\n    /**\n     * @param {string} key\n     * @param {any} value\n     *\n     * @returns {void}\n     */\n    constructor(key: string, value: any): void {\n        this._key = key;\n        this._value = value;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._key;\n    }\n\n    /**\n     * @returns {any}\n     */\n    getValue(): any {\n        return this._value;\n    }\n\n    /**\n     * @param {EnumEntry} entry\n     *\n     * @returns {boolean}\n     */\n    equals(entry: EnumEntry): boolean {\n        return entry.getKey() === this._key;\n    }\n}\n\nexport { EnumEntry };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst MUTATION_TYPE_INSERT: string = \"INSERT\";\nconst MUTATION_TYPE_UPDATE: string = \"UPDATE\";\nconst MUTATION_TYPE_UPSERT: string = \"UPSERT\";\nconst MUTATION_TYPE_DELETE: string = \"DELETE\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass MutationTypeEnum {\n    /**\n     * @returns {EnumEntry}\n     */\n    static INSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_INSERT, MUTATION_TYPE_INSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPDATE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPDATE, MUTATION_TYPE_UPDATE);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPSERT, MUTATION_TYPE_UPSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static DELETE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_DELETE, MUTATION_TYPE_DELETE);\n    }\n}\n\nexport { MutationTypeEnum };\n","// @flow strict\n/**\n * Error constants.\n */\nconst ERROR_NAME: string = \"HadesValidationError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesValidationError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return ERROR_NAME;\n    }\n\n    /**\n     * @param {string} value\n     *\n     * @returns {void}\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesValidationError };\n","// @flow strict\n/* global TableRowType */\nimport type { Schema } from \"./Schema\";\nimport { Mutation } from \"../objects/Mutation\";\nimport type { Table } from \"../database/Table\";\nimport type { Session } from \"../database/Session\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Model {\n    _session: Session;\n    _tableKey: string;\n    _fields: ModelFieldsType;\n    _ModelClass: Class<Model>;\n    _modelId: ModelIdentifierType;\n    _identifierKey: ModelIdentifierType;\n\n    static session: Session;\n    static tableKey: string;\n    static identifierKey: ModelIdentifierType;\n\n    static fields: () => Schema;\n    static toString: () => string;\n    static reducer: (action: ActionType) => void;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {ModelIdentifierType} modelId\n     *\n     * @returns {void}\n     */\n    constructor(ModelClass: Class<Model>, modelId: ModelIdentifierType): void {\n        this._modelId = modelId;\n        this._ModelClass = ModelClass;\n        this._session = this._ModelClass.session;\n        this._tableKey = this._ModelClass.tableKey;\n        this._identifierKey = this._ModelClass.identifierKey;\n\n        const tableOrNull: Table | null = this._getTableInstanceOrNull();\n\n        if (tableOrNull === null) {\n            throw new HadesValidationError(\n                \"Cannot get Model instance with missing Table.\"\n            );\n        } else {\n            // TODO: For now we'll have to referece _rows directly if we want\n            // to maintain all constructed field class instances.\n            const tableRowsOrNull: Model | null =\n                tableOrNull._rows[this._modelId] ?? null;\n\n            if (tableRowsOrNull === null) {\n                throw new HadesValidationError(\n                    `No data exists for Model instance with ID '${modelId}'.`\n                );\n            } else {\n                this._fields = tableRowsOrNull;\n            }\n        }\n    }\n\n    /**\n     * @param {TableRowType} fields\n     *\n     * @returns {void}\n     */\n    update(fields: TableRowType): void {\n        this._session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this._ModelClass,\n                type: MutationTypeEnum.UPDATE(),\n                modelId: this._fields[this._identifierKey],\n            })\n        );\n    }\n\n    /**\n     * @returns {void}\n     */\n    delete(): void {\n        this._session.applyMutation(\n            new Mutation({\n                ModelClass: this._ModelClass,\n                type: MutationTypeEnum.DELETE(),\n                modelId: this._fields[this._identifierKey],\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     *\n     * @returns {void}\n     */\n    static create(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.INSERT(),\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     *\n     * @returns {void}\n     */\n    static upsert(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.UPSERT(),\n            })\n        );\n    }\n\n    /**\n     * @returns {void}\n     */\n    static deleteAll(): void {\n        this.session.applyMutation(\n            new Mutation({\n                ModelClass: this,\n                willApplyToEntireTable: true,\n                type: MutationTypeEnum.DELETE(),\n            })\n        );\n    }\n\n    /**\n     * @param {ModelIdentifierType} modelId\n     *\n     * @returns {Model}\n     */\n    static withId(modelId: ModelIdentifierType): Model {\n        return new Model(this, modelId);\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    static getTableKeyOrNull(): string | null {\n        return this.tableKey || null;\n    }\n\n    /**\n     * @param {string} tableKey\n     *\n     * @returns {void}\n     */\n    static addTableKey(tableKey: string): void {\n        this.tableKey = tableKey;\n    }\n\n    /**\n     * @param {ModelIdentifierType} identifierKey\n     *\n     * @returns {void}\n     */\n    static addIdentifierKey(identifierKey: ModelIdentifierType): void {\n        this.identifierKey = identifierKey;\n    }\n\n    /**\n     * @param {Session} session\n     *\n     * @returns {void}\n     */\n    static addSession(session: Session): void {\n        this.session = session;\n    }\n\n    /**\n     * @returns {Table|null}\n     */\n    _getTableInstanceOrNull(): Table | null {\n        return this?._session.getState()[this._tableKey ?? \"\"] || null;\n    }\n}\n\nexport { Model };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst FIELD_TYPE_IDENTIFIER: string = \"IDENTIFIER\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201010 Initial creation.\n */\nclass FieldTypeEnum {\n    /**\n     * @param {FieldClassType} [FieldClass]\n     *\n     * @returns {EnumEntry}\n     */\n    static IDENTIFIER(FieldClass: ?FieldClassType): EnumEntry {\n        return new EnumEntry(FIELD_TYPE_IDENTIFIER, FieldClass);\n    }\n}\n\nexport { FieldTypeEnum };\n","// @flow strict\n/* global TableRowType */\n/* global ModelFieldsType */\n/* global GLOBAL_INDEX_INVALID */\n/* global GLOBAL_TYPE_UNDEFINED */\n/* global GLOBAL_SEPARATOR_SPACE */\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"./Model\";\nimport { EnumEntry } from \"../objects/EnumEntry\";\nimport { FieldTypeEnum } from \"../objects/enums/FieldTypeEnum\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\nopaque type FieldDefinitionType = FieldClassType | EnumEntry;\nopaque type FieldInstancesType = [string, FieldDefinitionType];\nopaque type SchemaDefinitionType = {|\n    [fieldName: string]: FieldDefinitionType,\n|};\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200722 Initial creation.\n */\nclass Schema {\n    _schemaDefinition: SchemaDefinitionType;\n\n    /**\n     * @param {SchemaDefinitionType} schemaDefinition\n     *\n     * @returns {void}\n     */\n    constructor(schemaDefinition: SchemaDefinitionType): void {\n        this._schemaDefinition = schemaDefinition;\n    }\n\n    /**\n     * @param {FieldClassType} FieldClass\n     *\n     * @returns {EnumEntry}\n     */\n    static defineIdentifierField(FieldClass: FieldClassType): EnumEntry {\n        return FieldTypeEnum.IDENTIFIER(FieldClass);\n    }\n\n    /**\n     * @param {TableRowType} fieldValues\n     * @param {boolean} isIdentifierRequired\n     *\n     * @returns {ModelFieldsType}\n     * @throws {HadesValidationError}\n     */\n    castValuesAgainstDefinition(\n        fieldValues: TableRowType,\n        isIdentifierRequired: boolean\n    ): ModelFieldsType {\n        const definedIdentifierFieldNameOrNull:\n            | string\n            | null = this.getDefinedIdentifierFieldNameOrNull();\n        const fieldNameIdentifier: string =\n            definedIdentifierFieldNameOrNull || GLOBAL_DEFAULT_KEY_NAME_ID;\n\n        if (fieldValues[fieldNameIdentifier]) {\n            // Value for identifier field was provided.\n        } else if (isIdentifierRequired && definedIdentifierFieldNameOrNull) {\n            throw new HadesValidationError(\n                `Value is required for identifier field '${fieldNameIdentifier}'.`\n            );\n        } else {\n            // Value for identifier field was not provided but was also not required.\n        }\n\n        /**\n         * @param {SchemaDefinitionType} fieldInstances\n         * @param {FieldInstancesType} currentField\n         *\n         * @returns {SchemaDefinitionType}\n         */\n        function reduceSchemaDefinition(\n            fieldInstances: SchemaDefinitionType,\n            [fieldName, fieldValue]: FieldInstancesType\n        ): SchemaDefinitionType {\n            if (fieldValues[fieldName]) {\n                const FieldClass: FieldClassType =\n                fieldValue instanceof EnumEntry\n                    ? fieldValue.getValue()\n                    : fieldValue;\n                    \n                if (fieldValues[fieldName] instanceof FieldClass) {\n                    return {\n                        ...fieldInstances,\n                        [fieldName]: fieldValues[fieldName],\n                    };\n                } else {\n                    return {\n                        ...fieldInstances,\n                        [fieldName]: new FieldClass(fieldValues[fieldName]),\n                    };\n                }\n            } else {\n                return fieldInstances;\n            }\n        }\n\n        /**\n         * @returns {SchemaDefinitionType}\n         *\n         * @this Schema\n         */\n        function determineSchemaDefinitionBase(): SchemaDefinitionType {\n            if (definedIdentifierFieldNameOrNull) {\n                return {};\n            } else {\n                return {\n                    [GLOBAL_DEFAULT_KEY_NAME_ID]: Number(\n                        fieldValues[GLOBAL_DEFAULT_KEY_NAME_ID]\n                    ),\n                };\n            }\n        }\n\n        // $FlowIssue\n        return Object.entries(this._schemaDefinition).reduce(\n            reduceSchemaDefinition,\n            determineSchemaDefinitionBase.call(this)\n        );\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {TableRowType} fields\n     *\n     * @returns {void}\n     * @throws {HadesValidationError}\n     */\n    assertSchemaAllowsFieldsForMutation(\n        ModelClass: Class<Model>,\n        fields: TableRowType\n    ): void {\n        const fieldWhitelist: Array<string> = [GLOBAL_DEFAULT_KEY_NAME_ID];\n\n        /**\n         * @param {string} key\n         *\n         * @returns {boolean}\n         *\n         * @this Schema\n         */\n        function isFieldSuperfluous(key: string): boolean {\n            return (\n                fieldWhitelist.includes(key) === false &&\n                typeof this._schemaDefinition[key] === GLOBAL_TYPE_UNDEFINED\n            );\n        }\n\n        Object.keys(fields).forEach((key: string): void => {\n            if (isFieldSuperfluous.call(this, key)) {\n                throw new HadesValidationError(\n                    [\n                        `Cannot apply mutation to ${ModelClass.toString()} model,`,\n                        `found superfluous property '${key}'.`,\n                    ].join(GLOBAL_SEPARATOR_SPACE)\n                );\n            } else {\n                // Field is allowed.\n            }\n        });\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    getDefinedIdentifierFieldNameOrNull(): string | null {\n        // $FlowIssue\n        const fieldDefinitions: Array<FieldInstancesType> = Object.entries(\n            this._schemaDefinition\n        );\n        const fieldIdentifierIndex: number = fieldDefinitions.findIndex(\n            // $FlowIssue\n            // eslint-disable-next-line no-unused-vars\n            ([fieldName, fieldValue]: FieldInstancesType): boolean => {\n                return (\n                    fieldValue instanceof EnumEntry &&\n                    fieldValue.equals(FieldTypeEnum.IDENTIFIER())\n                );\n            }\n        );\n\n        if (fieldIdentifierIndex === GLOBAL_INDEX_INVALID) {\n            return null;\n        } else {\n            return fieldDefinitions[fieldIdentifierIndex][0];\n        }\n    }\n}\n\nexport { Schema };\n","// @flow strict\n/* global TableRowType */\n/* global GLOBAL_INDEX_INVALID */\n/* global GLOBAL_TYPE_UNDEFINED */\n/* global GLOBAL_SEPARATOR_SPACE */\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"../model/Model\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\ntype RowStorageType = {|\n    // eslint-disable-next-line flowtype/no-weak-types\n    [key: ModelIdentifierType]: any,\n|};\n\nopaque type MetaStorageType = {|\n    lastIdIncremental: number,\n    idBlacklist: Array<number>,\n|};\n\n/**\n * Table constants.\n */\nconst TABLE_NAME_PREFIX: string = \"table_\";\n\n/**\n * Counter constants.\n */\nconst INCREMENT_STEP: number = 1;\nconst INCREMENT_START: number = 0;\n\n/**\n * Radix constants.\n */\nconst RADIX_DECIMAL: number = 10;\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Table {\n    _keyTable: string;\n    _rows: RowStorageType;\n    _meta: MetaStorageType;\n    _keyIdentifierOrNull: ModelIdentifierType | null;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {void}\n     */\n    constructor(ModelClass: Class<Model>): void {\n        this._rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n        this._keyTable = this._getModelTableName(ModelClass);\n        this._keyIdentifierOrNull = this._getModelIdentifierFieldNameOrNull(\n            ModelClass\n        );\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._keyTable;\n    }\n\n    /**\n     * @returns {ModelIdentifierType}\n     */\n    getIdentifierKey(): string {\n        if (this._keyIdentifierOrNull) {\n            return this._keyIdentifierOrNull.toString();\n        } else {\n            return GLOBAL_DEFAULT_KEY_NAME_ID;\n        }\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    getRows(): RowStorageType {\n        return JSON.parse(JSON.stringify(this._rows));\n    }\n\n    /**\n     * @param {TableRowType} columns\n     *\n     * @returns {void}\n     */\n    insertRow(columns: TableRowType): void {\n        const identifierKey: string = this.getIdentifierKey();\n\n        if (\n            this._keyIdentifierOrNull &&\n            typeof columns[this._keyIdentifierOrNull] === GLOBAL_TYPE_UNDEFINED\n        ) {\n            throw new HadesValidationError(\n                [\n                    \"Cannot insert Table row with missing value for\",\n                    `defined identifier '${this._keyIdentifierOrNull}'.`,\n                ].join(GLOBAL_SEPARATOR_SPACE)\n            );\n        } else {\n            // We're using the default identifier. So, move on.\n        }\n\n        /**\n         * @returns {ModelIdentifierType}\n         *\n         * @this Table\n         */\n        function determineModelId(): ModelIdentifierType {\n            if (columns[identifierKey]) {\n                return columns[identifierKey];\n            } else {\n                return this._getNextId();\n            }\n        }\n\n        const modelId: ModelIdentifierType = determineModelId.call(this);\n\n        if (this._rows[modelId]) {\n            throw new HadesValidationError(\n                `Cannot insert new Table row since given ID '${modelId}' is not unique.`\n            );\n        } else {\n            this._rows[modelId] = {\n                ...columns,\n                [identifierKey]: modelId,\n            };\n\n            if (this._keyIdentifierOrNull) {\n                // Don't use metadata if we are using a defined identifier key.\n            } else {\n                const modelIdDecimal: number = parseInt(modelId, RADIX_DECIMAL);\n\n                if (columns[identifierKey]) {\n                    this._meta.idBlacklist.push(modelIdDecimal);\n                    this._meta.idBlacklist.sort(\n                        (a: number, b: number): number => a - b\n                    );\n                } else {\n                    this._meta.lastIdIncremental = modelIdDecimal;\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {ModelIdentifierType} rowId\n     * @param {TableRowType} columns\n     *\n     * @returns {void}\n     */\n    updateRow(rowId: ModelIdentifierType, columns: TableRowType): void {\n        Object.assign(this._rows[rowId], columns);\n    }\n\n    /**\n     * @param {TableRowType} columns\n     *\n     * @returns {void}\n     */\n    upsertRow(columns: TableRowType): void {\n        const identifierKey: ModelIdentifierType = this.getIdentifierKey();\n\n        if (columns[identifierKey] && this._rows[columns[identifierKey]]) {\n            this.updateRow(columns[identifierKey], columns);\n        } else {\n            this.insertRow(columns);\n        }\n    }\n\n    /**\n     * @param {ModelIdentifierType} rowId\n     *\n     * @returns {void}\n     */\n    deleteRow(rowId: ModelIdentifierType): void {\n        const { idBlacklist }: MetaStorageType = this._meta;\n        const rowIdBlacklistIndex: number = idBlacklist.indexOf(rowId);\n\n        if (rowIdBlacklistIndex === GLOBAL_INDEX_INVALID) {\n            // No need to clear this ID from the blacklist.\n        } else {\n            idBlacklist.splice(rowIdBlacklistIndex, 1);\n        }\n\n        delete this._rows[rowId.toString()];\n    }\n\n    /**\n     * @returns {void}\n     */\n    truncate(): void {\n        this._rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    _createStorageForRows(): RowStorageType {\n        return {};\n    }\n\n    /**\n     * @returns {MetaStorageType}\n     */\n    _createStorageForMeta(): MetaStorageType {\n        return {\n            idBlacklist: [],\n            lastIdIncremental: INCREMENT_START,\n        };\n    }\n\n    /**\n     * @returns {number}\n     */\n    _getNextId(): number {\n        const { idBlacklist, lastIdIncremental }: MetaStorageType = this._meta;\n        const nextIdIncremental: number = lastIdIncremental + INCREMENT_STEP;\n\n        /**\n         * @param {number} id\n         *\n         * @returns {number}\n         */\n        function findNextNonBlacklistedId(id: number): number {\n            const idBlacklistIndex: number = idBlacklist.indexOf(id);\n\n            if (idBlacklistIndex === GLOBAL_INDEX_INVALID) {\n                return id;\n            } else if (idBlacklistIndex === idBlacklist.length - 1) {\n                return id + INCREMENT_STEP;\n            } else {\n                return findNextNonBlacklistedId(id + INCREMENT_STEP);\n            }\n        }\n\n        return findNextNonBlacklistedId(nextIdIncremental);\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {string}\n     */\n    _getModelTableName(ModelClass: Class<Model>): string {\n        return `${TABLE_NAME_PREFIX}${ModelClass.toString().toLowerCase()}`;\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {ModelIdentifierType|null}\n     */\n    _getModelIdentifierFieldNameOrNull(\n        ModelClass: Class<Model>\n    ): ModelIdentifierType | null {\n        return ModelClass.fields().getDefinedIdentifierFieldNameOrNull();\n    }\n}\n\nexport { Table };\n","// @flow strict\n/**\n * Error constants.\n */\nconst ERROR_NAME: string = \"HadesUnexpectedValueError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesUnexpectedValueError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return ERROR_NAME;\n    }\n\n    /**\n     * @param {string} value\n     *\n     * @returns {void}\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesUnexpectedValueError };\n","// @flow strict\n/* global ModelFieldsType, TableRowType */\nimport type { Table } from \"./Table\";\nimport type { Model } from \"../model/Model\";\nimport type { Schema } from \"../model/Schema\";\nimport type { Mutation } from \"../objects/Mutation\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesUnexpectedValueError } from \"../objects/errors/HadesUnexpectedValueError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Session {\n    _state: StateType;\n    _models: Array<Class<Model>>;\n\n    /**\n     * @param {StateType} state\n     *\n     * @returns {void}\n     */\n    constructor(state: StateType): void {\n        this._state = state;\n    }\n\n    /**\n     * @returns {StateType}\n     */\n    getState(): StateType {\n        return this._state;\n    }\n\n    /**\n     * @returns {Array<Class<Model>>}\n     */\n    getModels(): Array<Class<Model>> {\n        return this._models;\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     *\n     * @returns {void}\n     */\n    addModels(models: Array<Class<Model>>): void {\n        this._models = models;\n    }\n\n    /**\n     * @param {StateType} object\n     *\n     * @returns {void}\n     */\n    mergeIntoState(object: StateType): void {\n        Object.assign(this._state, object);\n    }\n\n    /**\n     * @param {Mutation} mutation\n     *\n     * @returns {void}\n     * @throws {HadesUnexpectedValueError}\n     */\n    applyMutation(mutation: Mutation): void {\n        const type: EnumEntry = mutation.getType();\n        const ModelClass: Class<Model> = mutation.getModelClass();\n        const pointerModelTableOrNull: Table | null = this._getPointerForModelTableOrNull(\n            ModelClass\n        );\n\n        if (pointerModelTableOrNull) {\n            // Found pointer to model's table.\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Cannot apply mutation to Model without table pointer.\"\n            );\n        }\n\n        const modelIdOrNull: number | null = mutation.getModelIdOrNull();\n        const willApplyToEntireTable: boolean = mutation.getWillApplyToEntireTable();\n        const fieldsOrNull: ModelFieldsType | null = this._getModelFieldsConvertedForMutationOrNull(\n            ModelClass,\n            mutation.getFieldsOrNull(),\n            type.equals(MutationTypeEnum.INSERT())\n        );\n\n        if (type.equals(MutationTypeEnum.INSERT())) {\n            this._applyInsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.UPSERT())) {\n            this._applyUpsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.DELETE())) {\n            this._applyDeleteMutation(\n                pointerModelTableOrNull,\n                modelIdOrNull,\n                willApplyToEntireTable\n            );\n        } else if (type.equals(MutationTypeEnum.UPDATE())) {\n            this._applyUpdateMutation(\n                pointerModelTableOrNull,\n                fieldsOrNull,\n                modelIdOrNull\n            );\n        } else {\n            throw new HadesUnexpectedValueError(\n                `Unexpected mutation type '${type.getValue()}'.`\n            );\n        }\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {TableRowType|null} fieldsOrNull\n     * @param {boolean} isIdentifierFieldRequired\n     *\n     * @returns {ModelFieldsType|null}\n     */\n    _getModelFieldsConvertedForMutationOrNull(\n        ModelClass: Class<Model>,\n        fieldsOrNull: TableRowType | null,\n        isIdentifierFieldRequired: boolean\n    ): ModelFieldsType | null {\n        if (fieldsOrNull) {\n            const modelSchema: Schema = ModelClass.fields();\n\n            modelSchema.assertSchemaAllowsFieldsForMutation(\n                ModelClass,\n                fieldsOrNull\n            );\n\n            return modelSchema.castValuesAgainstDefinition(\n                fieldsOrNull,\n                isIdentifierFieldRequired\n            );\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {Table|null}\n     */\n    _getPointerForModelTableOrNull(ModelClass: Class<Model>): Table | null {\n        const tableKeyOrNull: string | null = ModelClass.getTableKeyOrNull();\n\n        if (tableKeyOrNull) {\n            return this._state[tableKeyOrNull];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {number|null} modelIdOrNull\n     * @param {boolean} willApplyToEntireTable\n     *\n     * @returns {void}\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyDeleteMutation(\n        pointerTable: Table,\n        modelIdOrNull: number | null,\n        willApplyToEntireTable: boolean\n    ): void {\n        if (willApplyToEntireTable) {\n            pointerTable.truncate();\n        } else if (modelIdOrNull) {\n            pointerTable.deleteRow(modelIdOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for DELETE MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {ModelFieldsType|null} fieldsOrNull\n     *\n     * @returns {void}\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyInsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: ModelFieldsType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.insertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for INSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {ModelFieldsType|null} fieldsOrNull\n     *\n     * @returns {void}\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: ModelFieldsType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.upsertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {ModelFieldsType|null} fieldsOrNull\n     * @param {number|null} modelIdOrNull\n     *\n     * @returns {void}\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpdateMutation(\n        pointerTable: Table,\n        fieldsOrNull: ModelFieldsType | null,\n        modelIdOrNull: number | null\n    ): void {\n        if (fieldsOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPDATE MutationType.\"\n            );\n        } else if (modelIdOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for UPDATE MutationType.\"\n            );\n        } else {\n            pointerTable.updateRow(modelIdOrNull, fieldsOrNull);\n        }\n    }\n}\n\nexport { Session };\n","// @flow strict\n/* global StateType */\n/* global ActionType */\nimport { Table } from \"./Table\";\nimport { Session } from \"./Session\";\nimport type { Model } from \"../model/Model\";\n\n/**\n * Type constants.\n */\nconst TYPE_FUNCTION: string = \"function\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Database {\n    _registeredModels: Array<Class<Model>>;\n\n    /**\n     * @param {Array<Class<Model>>} models\n     *\n     * @returns {void}\n     */\n    constructor(...models: Array<Class<Model>>): void {\n        this._registerModels(models);\n    }\n\n    /**\n     * @returns {Function}\n     */\n    reducer(): (state: StateType, action: ActionType) => StateType {\n        /**\n         * @param {StateType} [state]\n         * @param {ActionType} action\n         *\n         * @returns {StateType}\n         */\n        return (state: StateType = {}, action: ActionType): StateType => {\n            const session: Session = this._createSession(state);\n\n            this._forModelsInSessionCreateTablesIfNeeded(session);\n            this._forModelsInSessionApplyReducers(session, action);\n\n            return session.getState();\n        };\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     *\n     * @returns {void}\n     */\n    _registerModels(models: Array<Class<Model>>): void {\n        /**\n         * @param {Array<Class<Model>>} uniqueModels\n         * @param {Class<Model>} ModelClass\n         *\n         * @this Database\n         *\n         * @returns {Array<Class<Model>>}\n         */\n        function uniqueModelReducer(\n            uniqueModels: Array<Class<Model>>,\n            ModelClass: Class<Model>\n        ): Array<Class<Model>> {\n            if (uniqueModels.includes(ModelClass)) {\n                this._createWarningDuplicateModel(ModelClass.toString());\n            } else {\n                uniqueModels.push(ModelClass);\n            }\n\n            return uniqueModels;\n        }\n\n        this._registeredModels = models.reduce(\n            uniqueModelReducer.bind(this),\n            []\n        );\n    }\n\n    /**\n     * @param {StateType} state\n     *\n     * @returns {Session}\n     */\n    _createSession(state: StateType): Session {\n        const session: Session = new Session(state);\n\n        session.addModels(this._registeredModels);\n        this._registeredModels.forEach((ModelClass: Class<Model>): void => {\n            ModelClass.addSession(session);\n        });\n\n        return session;\n    }\n\n    /**\n     * @param {Session} session\n     *\n     * @returns {void}\n     */\n    _forModelsInSessionCreateTablesIfNeeded(session: Session): void {\n        session.getModels().forEach((ModelClass: Class<Model>): void => {\n            const tableKeyOrNull:\n                | string\n                | null = ModelClass.getTableKeyOrNull();\n\n            if (tableKeyOrNull && session.getState()[tableKeyOrNull]) {\n                // Table already exists.\n            } else {\n                const table: Table = new Table(ModelClass);\n                const tableKey: string = table.getKey();\n\n                ModelClass.addTableKey(tableKey);\n                ModelClass.addIdentifierKey(table.getIdentifierKey());\n\n                session.mergeIntoState({ [tableKey]: table });\n            }\n        });\n    }\n\n    /**\n     * @param {Session} session\n     * @param {ActionType} action\n     *\n     * @returns {void}\n     */\n    _forModelsInSessionApplyReducers(\n        session: Session,\n        action: ActionType\n    ): void {\n        session.getModels().forEach((ModelClass: Class<Model>): void => {\n            if (typeof ModelClass.reducer === TYPE_FUNCTION) {\n                ModelClass.reducer(action);\n            } else {\n                // No reducer defined for this model.\n            }\n        });\n    }\n\n    /**\n     * @param {string} modelName\n     *\n     * @returns {void}\n     */\n    _createWarningDuplicateModel(modelName: string): void {\n        console.warn(`Tried to register duplicate Model: '${modelName}'.`);\n    }\n}\n\nexport { Database };\n"],"sourceRoot":""}